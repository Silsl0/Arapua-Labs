// ==========================
// SertAI — Lençóis Maranhenses (Robust MVP)
// Google Earth Engine — JavaScript
// ==========================

// -------- General parameters --------
var useWDPA      = false;              // true: try park polygon (WDPA) + BBox; false: only BBox ∩ Brazil land
var wdpaBufferKm = 0;                  // buffer around park (if useWDPA=true). e.g., 5
var scaleOut     = 10;                 // meters (S1 ~10 m)
var exportFolder = 'SertAI_GEE_Exports';

// Dates (adjust as needed)
var wetStart  = '2024-03-01';  // wet season: Mar–Jun
var wetEnd    = '2024-06-30';
var dryStart  = '2024-08-01';  // dry season: Aug–Sep (or Jul–Oct)
var dryEnd    = '2024-09-30';

// -------- 1) AOI — BBox ∩ Brazil land (with optional WDPA) --------
// Base BBox (freely adjust)
var aoiBBox = ee.Geometry.Rectangle({
  coords: [-43.30, -2.60, -42.70, -2.00], // [minLon, minLat, maxLon, maxLat]
  geodesic: false
});

// Brazil land (remove ocean)
var brasilTerra = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017')
  .filter(ee.Filter.eq('country_na', 'Brazil'))
  .geometry();

// Start with BBox ∩ Brazil
var aoiBase = aoiBBox.intersection(brasilTerra, ee.ErrorMargin(1));

// (Optional) try Park polygon (WDPA) with fallback
var aoiFinal;
if (useWDPA) {
  var wdpaCand = ee.FeatureCollection('WCMC/WDPA/current/polygons')
    // tolerant filter (avoids accent issues)
    .filter(ee.Filter.stringContains('NAME', 'Maranhenses'));
  print('WDPA candidates:', wdpaCand.size());

  var wdpaGeom = ee.FeatureCollection(wdpaCand).geometry();
  if (wdpaBufferKm > 0) {
    wdpaGeom = wdpaGeom.buffer(wdpaBufferKm * 1000);
  }

  // Intersect with the BBox (keeps spatial control)
  var wdpaAoi = aoiBBox.intersection(wdpaGeom, ee.ErrorMargin(1));

  // If WDPA fails (size==0 or empty intersection), fall back to BBox∩Brazil
  var wdpaAreaKm2 = ee.Number(wdpaAoi.area(1)).divide(1e6);
  print('AOI area (WDPA ∩ BBox) km²:', wdpaAreaKm2);

  aoiFinal = ee.Algorithms.If(
    wdpaCand.size().gt(0).and(wdpaAreaKm2.gt(0)),
    wdpaAoi,
    aoiBase
  );
  aoiFinal = ee.Geometry(aoiFinal);
} else {
  aoiFinal = aoiBase;
}

// Useful checks
print('Does BBox intersect Brazil land?', aoiBBox.intersects(brasilTerra, ee.ErrorMargin(1)));
print('Final AOI area (km²):', ee.Number(aoiFinal.area(1)).divide(1e6));

// Visual
Map.centerObject(aoiFinal, 10);
Map.addLayer(aoiFinal, {color: 'yellow'}, 'Final AOI');

// Export AOI (GeoJSON)
Export.table.toDrive({
  collection: ee.FeatureCollection(ee.Feature(aoiFinal, {})),
  description: 'AOI_LencoisMaranhenses_Final',
  fileFormat: 'GeoJSON',
  folder: exportFolder
});

// -------- Helpers --------

// dB <-> linear
function toDB(img) { return img.log10().multiply(10); }
function toLin(imgDb){ return ee.Image(10).pow(imgDb.divide(10)); }

// Sentinel-1 GRD (IW, VV/VH) — median mosaic
function s1GRDMosaic(start, end) {
  var orbitFilter = ee.Filter.or(
    ee.Filter.eq('orbitProperties_pass', 'ASCENDING'),
    ee.Filter.eq('orbitProperties_pass', 'DESCENDING')
  );

  var col = ee.ImageCollection('COPERNICUS/S1_GRD')
    .filterBounds(aoiFinal)
    .filterDate(start, end)
    .filter(ee.Filter.eq('instrumentMode', 'IW'))
    .filter(ee.Filter.eq('resolution_meters', 10))
    .filter(orbitFilter) // <- fix using ee.Filter.or(...)
    .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VV'))
    .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VH'))
    .filter(ee.Filter.eq('productType', 'GRD'))
    .map(function(img){
      var angle = img.select('angle');
      var mask = angle.gt(30).and(angle.lt(45)); // remove extremes
      return img.updateMask(mask)
                .select(['VV','VH'])
                .copyProperties(img, img.propertyNames());
    });

  var med = col.median().clip(aoiFinal).rename(['VV','VH']);
  return med;
}

// Otsu threshold (single band)
function otsuThreshold(image, region, scale) {
  var band = image;
  var hist = band.reduceRegion({
    reducer: ee.Reducer.histogram({maxBuckets: 256}),
    geometry: region,
    scale: scale,
    bestEffort: true
  }).get(band.bandNames().get(0));
  hist = ee.Dictionary(hist);
  var counts = ee.Array(hist.get('histogram'));
  var means  = ee.Array(hist.get('bucketMeans'));
  var total = counts.reduce(ee.Reducer.sum(), [0]).get([0]);
  var sum = means.multiply(counts).reduce(ee.Reducer.sum(), [0]).get([0]);
  var size = counts.length().get([0]);

  var bcVar = ee.List.sequence(0, ee.Number(size).subtract(1)).map(function(i){
    i = ee.Number(i);
    var c1 = counts.slice(0, 0, i.add(1)).reduce(ee.Reducer.sum(), [0]).get([0]);
    var c2 = ee.Number(total).subtract(c1);
    var m1 = means.slice(0, 0, i.add(1)).multiply(counts.slice(0, 0, i.add(1)))
                .reduce(ee.Reducer.sum(), [0]).get([0]).divide(c1);
    var m2 = ee.Number(sum).subtract(
               means.slice(0, 0, i.add(1)).multiply(counts.slice(0, 0, i.add(1)))
               .reduce(ee.Reducer.sum(), [0]).get([0])
             ).divide(c2);
    var w1 = ee.Number(c1).divide(total);
    var w2 = ee.Number(c2).divide(total);
    return w1.multiply(w2).multiply(ee.Number(m1).subtract(m2).pow(2));
  });

  var idx = ee.List(bcVar).indexOf(ee.List(bcVar).reduce(ee.Reducer.max()));
  var threshold = ee.Number(ee.Array(means).get([idx]));
  return threshold;
}

// Area (km²) of a mask
function areaKm2(mask) {
  var pixArea = ee.Image.pixelArea().divide(1e6);
  var areaImg = pixArea.updateMask(mask);
  var area = areaImg.reduceRegion({
    reducer: ee.Reducer.sum(),
    geometry: aoiFinal,
    scale: scaleOut,
    maxPixels: 1e13
  }).get('area');
  return ee.Number(area);
}

// -------- 2) Sentinel-1 — wet/dry mosaics + ΔMoisture --------
var wet = s1GRDMosaic(wetStart, wetEnd);
var dry = s1GRDMosaic(dryStart, dryEnd);

var wetDb = toDB(wet);
var dryDb = toDB(dry);

// ΔMoisture (ΔVV in dB)
var dVV = wetDb.select('VV').subtract(dryDb.select('VV')).rename('dVV_db');

Map.addLayer(wetDb.select('VV'), {min:-18, max:2}, 'S1 VV (wet) dB', false);
Map.addLayer(dryDb.select('VV'), {min:-18, max:2}, 'S1 VV (dry) dB', false);
Map.addLayer(dVV, {min:-3, max:3, palette:['#2c7bb6','#ffffbf','#d7191c']}, 'ΔMoisture (dVV)');

Export.image.toDrive({
  image: dVV,
  description: 'Delta_Moisture_S1_dVV',
  region: aoiFinal,
  scale: scaleOut,
  maxPixels: 1e13,
  folder: exportFolder
});

// -------- 3) Lagoon mask (Otsu on linear VV) --------
var wetVV_lin = wet.select('VV');
var thrWet = otsuThreshold(wetVV_lin, aoiFinal, scaleOut);
var waterWet = wetVV_lin.lte(thrWet).rename('waterWet');

var dryVV_lin = dry.select('VV');
var thrDry = otsuThreshold(dryVV_lin, aoiFinal, scaleOut);
var waterDry = dryVV_lin.lte(thrDry).rename('waterDry');

// Light cleanup
var kernel = ee.Kernel.circle({radius:1});
waterWet = waterWet.focal_mode({kernel: kernel, iterations:1});
waterDry = waterDry.focal_mode({kernel: kernel, iterations:1});

Map.addLayer(waterWet.selfMask(), {palette:['#0d88e6']}, 'Water (wet season)', true);
Map.addLayer(waterDry.selfMask(), {palette:['#94c6ff']}, 'Water (dry season)', false);

// Areas (km²)
var areaWet_km2 = areaKm2(waterWet);
var areaDry_km2 = areaKm2(waterDry);
print('Lagoon area — Wet (km²):', areaWet_km2);
print('Lagoon area — Dry (km²):', areaDry_km2);
print('ΔArea (km²):', ee.Number(areaWet_km2).subtract(areaDry_km2));

// Vectors (GeoJSON)
var waterWetVec = waterWet.selfMask().reduceToVectors({
  geometry: aoiFinal, scale: scaleOut,
  geometryType: 'polygon', labelProperty: 'class', maxPixels: 1e13
});
var waterDryVec = waterDry.selfMask().reduceToVectors({
  geometry: aoiFinal, scale: scaleOut,
  geometryType: 'polygon', labelProperty: 'class', maxPixels: 1e13
});

Export.table.toDrive({
  collection: waterWetVec,
  description: 'Polygons_Lagoons_Wet',
  fileFormat: 'GeoJSON',
  folder: exportFolder
});
Export.table.toDrive({
  collection: waterDryVec,
  description: 'Polygons_Lagoons_Dry',
  fileFormat: 'GeoJSON',
  folder: exportFolder
});

// -------- 4) Climate drivers — RAIN (GPM V07→fallback CHIRPS) & WIND (ERA5 HOURLY→monthly) --------

// Jan–Dec/2024 (adjust if you want another window)
var monthlyStart = ee.Date('2024-01-01');
var monthlyEnd   = ee.Date('2025-01-01');
var months = ee.List.sequence(0, 11);

// ==== RAIN ====
// 1) Try GPM IMERG V07 (monthly)
var gpmV07 = ee.ImageCollection('NASA/GPM_L3/IMERG_MONTHLY_V07')
  .filterDate(monthlyStart, monthlyEnd)
  .select(['precipitation']); // mm/month

// 2) If GPM V07 is empty, use daily CHIRPS and aggregate to monthly sum (mm/month)
var chirpsDaily = ee.ImageCollection('UCSB-CHG/CHIRPS/DAILY')
  .filterDate(monthlyStart, monthlyEnd)
  .select(['precipitation']); // mm/day

var chirpsMonthlyList = months.map(function(m){
  var mStart = monthlyStart.advance(ee.Number(m), 'month');
  var mEnd   = mStart.advance(1, 'month');
  // sum of days in month => mm/month
  var mImg = chirpsDaily.filterDate(mStart, mEnd).sum()
    .set('system:time_start', mStart.millis())
    .rename('precipitation');
  return mImg;
});
var chirpsMonthly = ee.ImageCollection.fromImages(chirpsMonthlyList);

// Auto-select: GPM V07 if exists; otherwise, CHIRPS monthly
var rainMonthlyCol = ee.ImageCollection(
  ee.Algorithms.If(gpmV07.size().gt(0), gpmV07, chirpsMonthly)
);

// Series (month by month) — spatial mean over AOI (robust)
var rainMonthlyTable = ee.FeatureCollection(rainMonthlyCol.map(function(img){
  // ensure AOI doesn’t produce nulls over masked areas
  var imgOk = img.unmask(0);

  var mean = imgOk.reduceRegion({
    reducer: ee.Reducer.mean(),
    geometry: aoiFinal,
    scale: 10000,
    bestEffort: true
  }).get('precipitation');

  // force Number and add useful metadata
  return ee.Feature(null, {
    'date': ee.Date(img.get('system:time_start')).format('YYYY-MM'),
    'precip_mm': ee.Number(mean),
    'src': ee.String(ee.Algorithms.If(gpmV07.size().gt(0), 'GPMv07', 'CHIRPS'))
  });
}));

print('Monthly rain — 2024 (GPMv07 or CHIRPS)', rainMonthlyTable);

// (optional) preview first month to confirm we have a number:
print('Rain example (Jan):', ee.Feature(rainMonthlyTable.first()).toDictionary());

// Export CSV
Export.table.toDrive({
  collection: rainMonthlyTable,
  description: 'RAIN_monthly_2024_GPMv07_fallback_CHIRPS',
  fileFormat: 'CSV',
  folder: exportFolder
});

// ==== WIND ====
// ERA5-Land HOURLY → monthly mean of u10 and v10
var era5Hourly = ee.ImageCollection('ECMWF/ERA5_LAND/HOURLY')
  .filterDate(monthlyStart, monthlyEnd)
  .select(['u_component_of_wind_10m','v_component_of_wind_10m']); // m/s

var windMonthlyImgs = months.map(function(m){
  var mStart = monthlyStart.advance(ee.Number(m), 'month');
  var mEnd   = mStart.advance(1, 'month');
  // temporal mean over the month
  var mMean = era5Hourly.filterDate(mStart, mEnd).mean()
    .set('system:time_start', mStart.millis());
  return mMean;
});
var windMonthlyCol = ee.ImageCollection.fromImages(windMonthlyImgs);

// Series (month by month) — spatial mean over AOI + magnitude & direction (robust)
var windMonthlyTable = ee.FeatureCollection(windMonthlyCol.map(function(img){
  // ERA5-Land HOURLY is complete, but ensure no nulls
  var imgOk = img.unmask(0);

  var stats = imgOk.reduceRegion({
    reducer: ee.Reducer.mean(),
    geometry: aoiFinal,
    scale: 10000,
    bestEffort: true
  });

  var u = ee.Number(stats.get('u_component_of_wind_10m'));
  var v = ee.Number(stats.get('v_component_of_wind_10m'));
  var speed = u.hypot(v);                 // m/s
  var dirRad = v.atan2(u);                // rad (x=u, y=v)
  var dirDeg = dirRad.multiply(180/Math.PI); // degrees, math convention

  return ee.Feature(null, {
    'date': ee.Date(img.get('system:time_start')).format('YYYY-MM'),
    'u10': u, 'v10': v,
    'speed_ms': speed,
    'dir_deg_math': dirDeg
  });
}));

print('ERA5 monthly wind — 2024 (aggregated from HOURLY)', windMonthlyTable);
print('Wind example (Jan):', ee.Feature(windMonthlyTable.first()).toDictionary());

// Export CSV
Export.table.toDrive({
  collection: windMonthlyTable,
  description: 'ERA5_wind_monthly_2024_from_HOURLY',
  fileFormat: 'CSV',
  folder: exportFolder
});

// -------- 5) Sentinel-2 (visual validation) --------
var s2 = ee.ImageCollection('COPERNICUS/S2_SR')
  .filterBounds(aoiFinal)
  .filterDate(wetStart, wetEnd)
  .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 20))
  .median()
  .clip(aoiFinal);

Map.addLayer(s2, {bands:['B4','B3','B2'], min:0, max:3000}, 'Sentinel-2 (wet) RGB', false);

// -------- 6) Offset Tracking (exports to run outside GEE) --------
var pair1_A = wet.select('VV').toFloat().clip(aoiFinal);
var pair1_B = dry.select('VV').toFloat().clip(aoiFinal);
var proj = pair1_A.projection().atScale(scaleOut);
pair1_A = pair1_A.reproject({crs: proj});
pair1_B = pair1_B.reproject({crs: proj});

Export.image.toDrive({
  image: pair1_A,
  description: 'S1_GRD_VV_wet_forOffset',
  region: aoiFinal,
  scale: scaleOut,
  maxPixels: 1e13,
  folder: exportFolder
});
Export.image.toDrive({
  image: pair1_B,
  description: 'S1_GRD_VV_dry_forOffset',
  region: aoiFinal,
  scale: scaleOut,
  maxPixels: 1e13,
  folder: exportFolder
});

// Placeholder for manually drawn transects
var transectos = /* color: #00ffff */ ee.FeatureCollection([]);
Map.addLayer(transectos, {color:'#00ffff'}, 'Transects (draw)');

// -------- 7) Water stack for final export --------
var waterStack = waterWet.rename('water_wet').addBands(waterDry.rename('water_dry'));
Export.image.toDrive({
  image: waterStack,
  description: 'Water_wet_dry_stack',
  region: aoiFinal,
  scale: scaleOut,
  maxPixels: 1e13,
  folder: exportFolder
});

// -------- 8) Final previews --------
Map.addLayer(wetDb.select('VV'), {min:-18, max:2, palette:['#1a1a1a','#c0d9ff','#ffffff']}, 'VV dB (wet) styled', false);
Map.addLayer(waterWet.selfMask(), {palette:['#00a6ff']}, 'Lagoons (wet) — final', true);
Map.addLayer(dVV, {min:-3, max:3, palette:['#2c7bb6','#ffffbf','#d7191c']}, 'ΔMoisture — final', false);


// ===== Quick charts =====

// Monthly rainfall (mm)
var chartRain = ui.Chart.feature.byFeature(rainMonthlyTable, 'date', ['precip_mm'])
  .setOptions({
    title: 'Monthly rainfall in AOI (mm) — 2024',
    hAxis: {title: 'Month'},
    vAxis: {title: 'mm/month'},
    legend: {position: 'none'}
  });
print(chartRain);

// Monthly wind speed (m/s)
var chartWind = ui.Chart.feature.byFeature(windMonthlyTable, 'date', ['speed_ms'])
  .setOptions({
    title: '10 m Wind (monthly mean) — 2024',
    hAxis: {title: 'Month'},
    vAxis: {title: 'm/s'},
    legend: {position: 'none'}
  });
print(chartWind);

// (optional) directions — quick check
var chartDir = ui.Chart.feature.byFeature(windMonthlyTable, 'date', ['dir_deg_math'])
  .setOptions({
    title: 'Mean direction (degrees, math convention) — 2024',
    hAxis: {title: 'Month'},
    vAxis: {title: 'degrees'},
    legend: {position: 'none'}
  });
print(chartDir);

var wetArea = areaWet_km2;
var dryArea = areaDry_km2;
var deltaArea = wetArea.subtract(dryArea);
var pct = deltaArea.divide(dryArea).multiply(100);

print(
  ee.String('Summary: Between Mar–Jun/2024, lagoon area increased by ')
    .cat(ee.Number(pct).format('%.1f')).cat('% (from ')
    .cat(ee.Number(dryArea).format('%.1f')).cat(' to ')
    .cat(ee.Number(wetArea).format('%.1f')).cat(' km²).')
);


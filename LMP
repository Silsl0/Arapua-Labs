// ==========================
// SertAI — Lençóis Maranhenses (MVP robusto)
// Google Earth Engine — JavaScript
// ==========================

// -------- Parâmetros gerais --------
var useWDPA     = false;               // true: tenta usar polígono do parque (WDPA) + BBox; false: só BBox ∩ Brasil
var wdpaBufferKm = 0;                  // buffer ao redor do parque (se useWDPA=true). Ex.: 5
var scaleOut    = 10;                  // metros (S1 ~10 m)
var exportFolder = 'SertAI_GEE_Exports';

// Datas (ajuste conforme quiser)
var wetStart  = '2024-03-01';  // chuvoso: mar–jun
var wetEnd    = '2024-06-30';
var dryStart  = '2024-08-01';  // seco: ago–set (ou jul–out)
var dryEnd    = '2024-09-30';

// -------- 1) AOI — BBox ∩ Terra do Brasil (com opção WDPA) --------
// BBox base (ajuste livre)
var aoiBBox = ee.Geometry.Rectangle({
  coords: [-43.30, -2.60, -42.70, -2.00], // [minLon, minLat, maxLon, maxLat]
  geodesic: false
});

// Terra do Brasil (remove mar)
var brasilTerra = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017')
  .filter(ee.Filter.eq('country_na', 'Brazil'))
  .geometry();

// Começa com BBox ∩ Brasil
var aoiBase = aoiBBox.intersection(brasilTerra, ee.ErrorMargin(1));

// (Opcional) tentar polígono do Parque (WDPA) com fallback
var aoiFinal;
if (useWDPA) {
  var wdpaCand = ee.FeatureCollection('WCMC/WDPA/current/polygons')
    // filtro tolerante (evita problema de acentos)
    .filter(ee.Filter.stringContains('NAME', 'Maranhenses'));
  print('WDPA candidatos:', wdpaCand.size());

  var wdpaGeom = ee.FeatureCollection(wdpaCand).geometry();
  if (wdpaBufferKm > 0) {
    wdpaGeom = wdpaGeom.buffer(wdpaBufferKm * 1000);
  }

  // Interseção com a BBox (mantém controle espacial)
  var wdpaAoi = aoiBBox.intersection(wdpaGeom, ee.ErrorMargin(1));

  // Se WDPA falhar (size==0 ou interseção vazia), cai para BBox∩Brasil
  var wdpaAreaKm2 = ee.Number(wdpaAoi.area(1)).divide(1e6);
  print('Área AOI (WDPA ∩ BBox) km²:', wdpaAreaKm2);

  aoiFinal = ee.Algorithms.If(
    wdpaCand.size().gt(0).and(wdpaAreaKm2.gt(0)),
    wdpaAoi,
    aoiBase
  );
  aoiFinal = ee.Geometry(aoiFinal);
} else {
  aoiFinal = aoiBase;
}

// Checks úteis
print('BBox intersecta Brasil-terra?', aoiBBox.intersects(brasilTerra, ee.ErrorMargin(1)));
print('Área AOI final (km²):', ee.Number(aoiFinal.area(1)).divide(1e6));

// Visual
Map.centerObject(aoiFinal, 10);
Map.addLayer(aoiFinal, {color: 'yellow'}, 'AOI Final');

// Exportar AOI (GeoJSON)
Export.table.toDrive({
  collection: ee.FeatureCollection(ee.Feature(aoiFinal, {})),
  description: 'AOI_LencoisMaranhenses_Final',
  fileFormat: 'GeoJSON',
  folder: exportFolder
});

// -------- Helpers --------

// dB <-> linear
function toDB(img) { return img.log10().multiply(10); }
function toLin(imgDb){ return ee.Image(10).pow(imgDb.divide(10)); }

// Sentinel-1 GRD (IW, VV/VH) — mosaico mediano
function s1GRDMosaic(start, end) {
  var orbitFilter = ee.Filter.or(
    ee.Filter.eq('orbitProperties_pass', 'ASCENDING'),
    ee.Filter.eq('orbitProperties_pass', 'DESCENDING')
  );

  var col = ee.ImageCollection('COPERNICUS/S1_GRD')
    .filterBounds(aoiFinal)
    .filterDate(start, end)
    .filter(ee.Filter.eq('instrumentMode', 'IW'))
    .filter(ee.Filter.eq('resolution_meters', 10))
    .filter(orbitFilter) // <- correção usando ee.Filter.or(...)
    .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VV'))
    .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VH'))
    .filter(ee.Filter.eq('productType', 'GRD'))
    .map(function(img){
      var angle = img.select('angle');
      var mask = angle.gt(30).and(angle.lt(45)); // remove extremos
      return img.updateMask(mask)
                .select(['VV','VH'])
                .copyProperties(img, img.propertyNames());
    });

  var med = col.median().clip(aoiFinal).rename(['VV','VH']);
  return med;
}

// Otsu threshold (1 banda)
function otsuThreshold(image, region, scale) {
  var band = image;
  var hist = band.reduceRegion({
    reducer: ee.Reducer.histogram({maxBuckets: 256}),
    geometry: region,
    scale: scale,
    bestEffort: true
  }).get(band.bandNames().get(0));
  hist = ee.Dictionary(hist);
  var counts = ee.Array(hist.get('histogram'));
  var means  = ee.Array(hist.get('bucketMeans'));
  var total = counts.reduce(ee.Reducer.sum(), [0]).get([0]);
  var sum = means.multiply(counts).reduce(ee.Reducer.sum(), [0]).get([0]);
  var size = counts.length().get([0]);

  var bcVar = ee.List.sequence(0, ee.Number(size).subtract(1)).map(function(i){
    i = ee.Number(i);
    var c1 = counts.slice(0, 0, i.add(1)).reduce(ee.Reducer.sum(), [0]).get([0]);
    var c2 = ee.Number(total).subtract(c1);
    var m1 = means.slice(0, 0, i.add(1)).multiply(counts.slice(0, 0, i.add(1)))
                .reduce(ee.Reducer.sum(), [0]).get([0]).divide(c1);
    var m2 = ee.Number(sum).subtract(
               means.slice(0, 0, i.add(1)).multiply(counts.slice(0, 0, i.add(1)))
               .reduce(ee.Reducer.sum(), [0]).get([0])
             ).divide(c2);
    var w1 = ee.Number(c1).divide(total);
    var w2 = ee.Number(c2).divide(total);
    return w1.multiply(w2).multiply(ee.Number(m1).subtract(m2).pow(2));
  });

  var idx = ee.List(bcVar).indexOf(ee.List(bcVar).reduce(ee.Reducer.max()));
  var threshold = ee.Number(ee.Array(means).get([idx]));
  return threshold;
}

// Área (km²) de uma máscara
function areaKm2(mask) {
  var pixArea = ee.Image.pixelArea().divide(1e6);
  var areaImg = pixArea.updateMask(mask);
  var area = areaImg.reduceRegion({
    reducer: ee.Reducer.sum(),
    geometry: aoiFinal,
    scale: scaleOut,
    maxPixels: 1e13
  }).get('area');
  return ee.Number(area);
}

// -------- 2) Sentinel-1 — mosaicos chuvoso/seco + ΔUmidade --------
var wet = s1GRDMosaic(wetStart, wetEnd);
var dry = s1GRDMosaic(dryStart, dryEnd);

var wetDb = toDB(wet);
var dryDb = toDB(dry);

// ΔUmidade (ΔVV em dB)
var dVV = wetDb.select('VV').subtract(dryDb.select('VV')).rename('dVV_db');

Map.addLayer(wetDb.select('VV'), {min:-18, max:2}, 'S1 VV (chuvoso) dB', false);
Map.addLayer(dryDb.select('VV'), {min:-18, max:2}, 'S1 VV (seco) dB', false);
Map.addLayer(dVV, {min:-3, max:3, palette:['#2c7bb6','#ffffbf','#d7191c']}, 'ΔUmidade (dVV)');

Export.image.toDrive({
  image: dVV,
  description: 'Delta_Umidade_S1_dVV',
  region: aoiFinal,
  scale: scaleOut,
  maxPixels: 1e13,
  folder: exportFolder
});

// -------- 3) Máscara de lagoas (Otsu no VV linear) --------
var wetVV_lin = wet.select('VV');
var thrWet = otsuThreshold(wetVV_lin, aoiFinal, scaleOut);
var waterWet = wetVV_lin.lte(thrWet).rename('waterWet');

var dryVV_lin = dry.select('VV');
var thrDry = otsuThreshold(dryVV_lin, aoiFinal, scaleOut);
var waterDry = dryVV_lin.lte(thrDry).rename('waterDry');

// Limpeza leve
var kernel = ee.Kernel.circle({radius:1});
waterWet = waterWet.focal_mode({kernel: kernel, iterations:1});
waterDry = waterDry.focal_mode({kernel: kernel, iterations:1});

Map.addLayer(waterWet.selfMask(), {palette:['#0d88e6']}, 'Água (chuvoso)', true);
Map.addLayer(waterDry.selfMask(), {palette:['#94c6ff']}, 'Água (seco)', false);

// Áreas (km²)
var areaWet_km2 = areaKm2(waterWet);
var areaDry_km2 = areaKm2(waterDry);
print('Área de lagoas — Chuvoso (km²):', areaWet_km2);
print('Área de lagoas — Seco (km²):', areaDry_km2);
print('ΔÁrea (km²):', ee.Number(areaWet_km2).subtract(areaDry_km2));

// Vetores (GeoJSON)
var waterWetVec = waterWet.selfMask().reduceToVectors({
  geometry: aoiFinal, scale: scaleOut,
  geometryType: 'polygon', labelProperty: 'class', maxPixels: 1e13
});
var waterDryVec = waterDry.selfMask().reduceToVectors({
  geometry: aoiFinal, scale: scaleOut,
  geometryType: 'polygon', labelProperty: 'class', maxPixels: 1e13
});

Export.table.toDrive({
  collection: waterWetVec,
  description: 'Poligonos_Lagoas_Chuvoso',
  fileFormat: 'GeoJSON',
  folder: exportFolder
});
Export.table.toDrive({
  collection: waterDryVec,
  description: 'Poligonos_Lagoas_Seco',
  fileFormat: 'GeoJSON',
  folder: exportFolder
});

// -------- 4) Drivers climáticos — CHUVA (GPM V07→fallback CHIRPS) & VENTO (ERA5 HOURLY→mensal) --------

// Jan–Dez/2024 (ajuste se quiser outra janela)
var monthlyStart = ee.Date('2024-01-01');
var monthlyEnd   = ee.Date('2025-01-01');
var months = ee.List.sequence(0, 11);

// ==== CHUVA ====
// 1) Tenta GPM IMERG V07 (mensal)
var gpmV07 = ee.ImageCollection('NASA/GPM_L3/IMERG_MONTHLY_V07')
  .filterDate(monthlyStart, monthlyEnd)
  .select(['precipitation']); // mm/month

// 2) Se GPM V07 vier vazio, usa CHIRPS diário e agrega para soma mensal (mm/mês)
var chirpsDaily = ee.ImageCollection('UCSB-CHG/CHIRPS/DAILY')
  .filterDate(monthlyStart, monthlyEnd)
  .select(['precipitation']); // mm/day

var chirpsMonthlyList = months.map(function(m){
  var mStart = monthlyStart.advance(ee.Number(m), 'month');
  var mEnd   = mStart.advance(1, 'month');
  // soma dos dias do mês => mm/mês
  var mImg = chirpsDaily.filterDate(mStart, mEnd).sum()
    .set('system:time_start', mStart.millis())
    .rename('precipitation');
  return mImg;
});
var chirpsMonthly = ee.ImageCollection.fromImages(chirpsMonthlyList);

// Escolhe automaticamente: GPM V07 se existir; caso contrário, CHIRPS mensal
var rainMonthlyCol = ee.ImageCollection(
  ee.Algorithms.If(gpmV07.size().gt(0), gpmV07, chirpsMonthly)
);

// Série (mês a mês) — média espacial na AOI (robusto)
var rainMonthlyTable = ee.FeatureCollection(rainMonthlyCol.map(function(img){
  // garante que o AOI não gere nulos em áreas mascaradas
  var imgOk = img.unmask(0);

  var mean = imgOk.reduceRegion({
    reducer: ee.Reducer.mean(),
    geometry: aoiFinal,
    scale: 10000,
    bestEffort: true
  }).get('precipitation');

  // força Number e adiciona metadados úteis
  return ee.Feature(null, {
    'date': ee.Date(img.get('system:time_start')).format('YYYY-MM'),
    'precip_mm': ee.Number(mean),
    'src': ee.String(ee.Algorithms.If(gpmV07.size().gt(0), 'GPMv07', 'CHIRPS'))
  });
}));

print('Chuva mensal — 2024 (GPMv07 ou CHIRPS)', rainMonthlyTable);

// (opcional) visualize primeiro mês pra checar que veio número:
print('Exemplo chuva (jan):', ee.Feature(rainMonthlyTable.first()).toDictionary());


// Export CSV
Export.table.toDrive({
  collection: rainMonthlyTable,
  description: 'RAIN_mensal_2024_GPMv07_fallback_CHIRPS',
  fileFormat: 'CSV',
  folder: exportFolder
});


// ==== VENTO ====
// ERA5-Land HOURLY → média mensal de u10 e v10
var era5Hourly = ee.ImageCollection('ECMWF/ERA5_LAND/HOURLY')
  .filterDate(monthlyStart, monthlyEnd)
  .select(['u_component_of_wind_10m','v_component_of_wind_10m']); // m/s

var windMonthlyImgs = months.map(function(m){
  var mStart = monthlyStart.advance(ee.Number(m), 'month');
  var mEnd   = mStart.advance(1, 'month');
  // média temporal ao longo do mês
  var mMean = era5Hourly.filterDate(mStart, mEnd).mean()
    .set('system:time_start', mStart.millis());
  return mMean;
});
var windMonthlyCol = ee.ImageCollection.fromImages(windMonthlyImgs);

// Série (mês a mês) — média espacial na AOI + magnitude e direção (robusto)
var windMonthlyTable = ee.FeatureCollection(windMonthlyCol.map(function(img){
  // ERA5-Land HOURLY já é completo, mas vamos garantir sem nulos
  var imgOk = img.unmask(0);

  var stats = imgOk.reduceRegion({
    reducer: ee.Reducer.mean(),
    geometry: aoiFinal,
    scale: 10000,
    bestEffort: true
  });

  var u = ee.Number(stats.get('u_component_of_wind_10m'));
  var v = ee.Number(stats.get('v_component_of_wind_10m'));
  var speed = u.hypot(v);                 // m/s
  var dirRad = v.atan2(u);                // rad (x=u, y=v)
  var dirDeg = dirRad.multiply(180/Math.PI); // graus, convenção matemática

  return ee.Feature(null, {
    'date': ee.Date(img.get('system:time_start')).format('YYYY-MM'),
    'u10': u, 'v10': v,
    'speed_ms': speed,
    'dir_deg_math': dirDeg
  });
}));

print('ERA5 vento mensal — 2024 (agregado de HOURLY)', windMonthlyTable);
print('Exemplo vento (jan):', ee.Feature(windMonthlyTable.first()).toDictionary());

// Export CSV
Export.table.toDrive({
  collection: windMonthlyTable,
  description: 'ERA5_wind_mensal_2024_from_HOURLY',
  fileFormat: 'CSV',
  folder: exportFolder
});


// -------- 5) Sentinel-2 (validação visual) --------
var s2 = ee.ImageCollection('COPERNICUS/S2_SR')
  .filterBounds(aoiFinal)
  .filterDate(wetStart, wetEnd)
  .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 20))
  .median()
  .clip(aoiFinal);

Map.addLayer(s2, {bands:['B4','B3','B2'], min:0, max:3000}, 'Sentinel-2 (chuvoso) RGB', false);

// -------- 6) Offset Tracking (exports para rodar fora do GEE) --------
var pair1_A = wet.select('VV').toFloat().clip(aoiFinal);
var pair1_B = dry.select('VV').toFloat().clip(aoiFinal);
var proj = pair1_A.projection().atScale(scaleOut);
pair1_A = pair1_A.reproject({crs: proj});
pair1_B = pair1_B.reproject({crs: proj});

Export.image.toDrive({
  image: pair1_A,
  description: 'S1_GRD_VV_chuvoso_forOffset',
  region: aoiFinal,
  scale: scaleOut,
  maxPixels: 1e13,
  folder: exportFolder
});
Export.image.toDrive({
  image: pair1_B,
  description: 'S1_GRD_VV_seco_forOffset',
  region: aoiFinal,
  scale: scaleOut,
  maxPixels: 1e13,
  folder: exportFolder
});

// Placeholder para transectos desenhados manualmente
var transectos = /* color: #00ffff */ ee.FeatureCollection([]);
Map.addLayer(transectos, {color:'#00ffff'}, 'Transectos (desenhe)');

// -------- 7) Stack de água para export final --------
var waterStack = waterWet.rename('agua_chuvoso').addBands(waterDry.rename('agua_seco'));
Export.image.toDrive({
  image: waterStack,
  description: 'Agua_chuvoso_seco_stack',
  region: aoiFinal,
  scale: scaleOut,
  maxPixels: 1e13,
  folder: exportFolder
});

// -------- 8) Previews finais --------
Map.addLayer(wetDb.select('VV'), {min:-18, max:2, palette:['#1a1a1a','#c0d9ff','#ffffff']}, 'VV dB (chuvoso) estilizado', false);
Map.addLayer(waterWet.selfMask(), {palette:['#00a6ff']}, 'Lagoas (chuvoso) — final', true);
Map.addLayer(dVV, {min:-3, max:3, palette:['#2c7bb6','#ffffbf','#d7191c']}, 'ΔUmidade — final', false);

